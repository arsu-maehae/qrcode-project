<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QR Brick Breaker – Tight QR Blocks (Scannable)</title>
  <style>
    :root{ --bg:#0b0f14; --fg:#e6edf3; --card:#0f1720; --muted:#a7b1bb; --blue:#1e88ff; --teal:#14b8a6; --bd:rgba(255,255,255,.08); }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }

    /* layout */
    #wrap { min-height: 100vh; display:flex; flex-direction:column; align-items:center; gap:10px;
            padding:12px 8px calc(90px + env(safe-area-inset-bottom)); }
    canvas { background: var(--card); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.05); touch-action: none; }

    #hud { display:flex; gap:10px; align-items:center; justify-content:center; font-weight:600; flex-wrap:wrap; }
    .pill { padding: 6px 10px; border-radius: 999px; background: #111a24; border: 1px solid var(--bd); }
    #btnStart { cursor:pointer; background:var(--blue); border:none; color:white; padding:8px 14px; border-radius:10px; font-weight:700; }

    #controls { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; align-items:center; max-width:1000px }
    #qrPreviewWrap { display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
    #qrPreview { image-rendering: pixelated; background:#fff; padding:10px; border-radius:12px; box-shadow: 0 6px 20px rgba(0,0,0,.35); }

    a { color:#6ab7ff; }
    input[type="number"], input[type="range"] { background:#0b1220; color:var(--fg); border:1px solid rgba(255,255,255,.15); border-radius:8px; padding:4px 6px; }
    label { opacity:.85; font-size:13px; }
    #help { max-width: 980px; opacity:.85; line-height:1.4; font-size: 14px; text-align:center; padding:0 8px; }

    /* back button bottom-left */
    .back-fixed{ position:fixed; left:12px; bottom:calc(16px + env(safe-area-inset-bottom)); z-index:1000;
      display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px;
      border:1px solid var(--bd); background:rgba(255,255,255,.06); color:var(--fg); font-weight:700; cursor:pointer }
    .back-fixed svg{ opacity:.9 }

    /* mobile tweaks */
    @media (max-width: 640px){
      .pill{ padding:6px 8px; font-size:14px }
      #qrPreview{ width:150px; height:150px }
    }
  </style>
</head>
<body>
  <!-- ปุ่มย้อนกลับ (ซ้ายล่าง) -->
  <button id="backBtn" class="back-fixed" type="button" aria-label="ย้อนกลับ">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    ย้อนกลับ
  </button>

  <div id="wrap">
    <canvas id="game" width="900" height="600" aria-label="QR Brick Breaker"></canvas>

    <div id="hud">
      <div class="pill">คะแนน: <span id="score">0</span></div>
      <div class="pill">ด่าน: <span id="level">1</span></div>
      <div class="pill">ชีวิต: <span id="lives">3</span></div>
      <button id="btnStart">เริ่ม / รีเซ็ต</button>
    </div>

    <div id="controls">
      <div class="pill">อัปโหลดภาพ QR: <input type="file" id="fileQR" accept="image/*" /></div>
      <div class="pill"><label>โมดูล/ด้าน</label>
        <input id="modules" type="number" value="21" min="17" max="177" step="1" style="width:72px;" />
      </div>
      <div class="pill"><label>Quiet zone (modules)</label>
        <input id="quietModules" type="number" value="4" min="0" max="16" step="1" style="width:64px;" />
      </div>
      <div class="pill"><label>Threshold</label>
        <input id="thresh" type="number" value="128" min="0" max="255" step="1" style="width:64px;" />
      </div>
      <div class="pill" title="ย่อ/ขยายขนาดกริด (จำกัดความสูง ~50% จอ)">
        <label>ขนาดกริด (%)</label>
        <input id="scale" type="range" min="30" max="100" value="70" />
        <span id="scaleVal">70%</span>
      </div>
      <button id="btnBuild" style="cursor:pointer;background:#14b8a6;border:none;color:white;padding:8px 14px;border-radius:10px;font-weight:700;">
        ใช้ภาพ QR สร้างอิฐ
      </button>
    </div>

    <div id="qrPreviewWrap">
      <div class="pill" style="background:transparent;border:none;box-shadow:none"><b>สแกน QR ได้ตั้งแต่ตอนนี้เลย →</b></div>
      <img id="qrPreview" alt="ตัวอย่าง QR (สแกนได้)" draggable="false" width="180" height="180" />
    </div>

    <div id="help">
      เวอร์ชันนี้ทำให้โมดูล QR เป็น <b>บล็อกสี่เหลี่ยมติดกันสนิท</b> (ไม่มีช่องว่าง) เพื่อให้ <b>สแกนได้จริง</b> ขณะยังไม่เริ่มเกมด้วยค่ะ
    </div>
  </div>

  <script>
  // ---------- responsive canvas ----------
  const canvas = document.getElementById('game');
  function fitCanvas(){
    const baseW = 900, baseH = 600;
    const maxW = Math.min(window.innerWidth - 24, 1000);
    // กันชนแนวตั้งให้ HUD/controls/preview (มือถือเหลือพื้นที่มากขึ้น)
    const reserve = (window.innerWidth < 640) ? 360 : 260;
    const maxH = Math.max(180, Math.min(window.innerHeight - reserve, 700));
    const scale = Math.min(maxW/baseW, maxH/baseH, 1);
    canvas.style.width  = Math.round(baseW*scale) + 'px';
    canvas.style.height = Math.round(baseH*scale) + 'px';
  }
  addEventListener('resize', fitCanvas); fitCanvas();

  // ---------- game refs ----------
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const livesEl = document.getElementById('lives');
  const btnStart = document.getElementById('btnStart');
  const btnBuild = document.getElementById('btnBuild');
  const inpModules = document.getElementById('modules');
  const inpQuietModules = document.getElementById('quietModules');
  const inpThresh = document.getElementById('thresh');
  const inpScale = document.getElementById('scale');
  const scaleVal = document.getElementById('scaleVal');
  const fileQR = document.getElementById('fileQR');
  const qrPreview = document.getElementById('qrPreview');

  const state = {
    running:false, level:1, score:0, lives:3,
    paddle:{ x:canvas.width/2, y:canvas.height-28, w:120, h:12, speed:10 },
    ball:{ x:canvas.width/2, y:canvas.height-80, r:8, vx:0, vy:0, speed:7 },
    bricks:[], modules:21, gridScale:0.7, lastQRObjectURL:null, gridMeta:null
  };
  inpScale.addEventListener('input', ()=>{
    scaleVal.textContent = inpScale.value + '%';
    state.gridScale = parseInt(inpScale.value,10)/100;
    rebuildFromCurrentMatrix();
  });

  // ---------- QR matrix helpers ----------
  function brightness(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
  async function imageToMatrix(img, modules, quietPx, thresh){
    const off=document.createElement('canvas'); const N=Math.max(img.width,img.height);
    off.width=off.height=N; const octx=off.getContext('2d');
    const sc=Math.min(N/img.width, N/img.height); const w=img.width*sc, h=img.height*sc;
    octx.fillStyle='#fff'; octx.fillRect(0,0,N,N); octx.drawImage(img,(N-w)/2,(N-h)/2,w,h);
    const start=quietPx, end=N-quietPx, size=end-start, cell=size/modules, matrix=[];
    for(let r=0;r<modules;r++){
      const row=[];
      for(let c=0;c<modules;c++){
        const sx=Math.floor(start+c*cell), sy=Math.floor(start+r*cell);
        const sw=Math.max(1,Math.ceil(cell)), sh=Math.max(1,Math.ceil(cell));
        const data=octx.getImageData(sx,sy,sw,sh).data;
        let sum=0,cnt=0; for(let i=0;i<data.length;i+=4){ sum+=brightness(data[i],data[i+1],data[i+2]); cnt++; }
        row.push((sum/cnt)<thresh?1:0);
      }
      matrix.push(row);
    }
    return matrix;
  }

  function buildBricksFromMatrix(mat, quietModules=4){
    const rows=mat.length, cols=mat[0].length;
    const maxW = canvas.width - 16, maxH = Math.floor(canvas.height*0.5);
    const totalCols = cols + quietModules*2, totalRows = rows + quietModules*2;
    let moduleSize = Math.floor(Math.min(maxW/totalCols, maxH/totalRows));
    moduleSize = Math.max(6, moduleSize);
    const gridW = totalCols*moduleSize, gridH = totalRows*moduleSize;
    const startX = Math.floor((canvas.width - gridW)/2);
    const startY = 48;

    const bricks=[]; let id=1;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x=startX+(c+quietModules)*moduleSize;
        const y=startY+(r+quietModules)*moduleSize;
        const black=mat[r][c]===1;
        bricks.push({ id:id++, x,y, w:moduleSize,h:moduleSize, hp:black?2:1, type:black?'black':'white' });
      }
    }
    state.bricks=bricks;
    state.gridMeta={ startX,startY,moduleSize,cols,rows,quietModules };
  }

  let currentMatrix=null;
  function rebuildFromCurrentMatrix(){
    if(!currentMatrix) return;
    buildBricksFromMatrix(currentMatrix, state.gridMeta?state.gridMeta.quietModules:4);
    resetBall(true); state.running=false;
  }

  // ---------- draw ----------
  const ctx2=ctx;
  function drawQuietZone(){ if(!state.gridMeta) return;
    const {startX,startY,moduleSize,cols,rows,quietModules}=state.gridMeta;
    ctx2.fillStyle='#fff';
    ctx2.fillRect(startX,startY,(cols+quietModules*2)*moduleSize,(rows+quietModules*2)*moduleSize);
  }
  function drawPaddle(){ const p=state.paddle; ctx2.fillStyle='#b3e1ff'; ctx2.fillRect(Math.round(p.x-p.w/2),Math.round(p.y-p.h/2),p.w,p.h); }
  function drawBall(){ const b=state.ball; ctx2.fillStyle='#fff'; ctx2.beginPath(); ctx2.arc(Math.round(b.x),Math.round(b.y),b.r,0,Math.PI*2); ctx2.fill(); }
  function drawBricks(){ drawQuietZone(); for(const br of state.bricks){ if(br.hp<=0) continue; ctx2.fillStyle = br.type==='black' ? (br.hp===1?'#222':'#000') : '#fff'; ctx2.fillRect(br.x,br.y,br.w,br.h); } }
  function drawUI(){ const b=state.ball; if(!state.running && b.vx===0 && b.vy===0){ ctx2.fillStyle='rgba(0,0,0,0.35)'; ctx2.textAlign='center'; ctx2.font='bold 20px ui-sans-serif, system-ui'; ctx2.fillText('กด Space / แตะ เพื่อเริ่ม', canvas.width/2, canvas.height - 18); } }

  // ---------- physics ----------
  const stateRef=state;
  function resetBall(onPaddle=true){ const p=stateRef.paddle, b=stateRef.ball; b.x=p.x; b.y=p.y - p.h/2 - b.r - 2; b.vx=0; b.vy=0;
    if(!onPaddle){ const angle=(-60+Math.random()*120)*Math.PI/180; b.vx=Math.cos(angle)*b.speed; b.vy=Math.sin(angle)*b.speed; } }
  function updateHud(){ scoreEl.textContent=state.score; levelEl.textContent=state.level; livesEl.textContent=state.lives; }
  function newGame(){ state.level=1; state.score=0; state.lives=3; const mat=makeFallbackMatrix(state.modules); currentMatrix=mat; buildBricksFromMatrix(mat,4); resetBall(true); state.running=false; updateHud(); }

  function step(){
    requestAnimationFrame(step);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const p=state.paddle,b=state.ball;
    if(b.vx===0&&b.vy===0){ b.x=p.x; b.y=p.y - p.h/2 - b.r - 2; }
    b.x+=b.vx; b.y+=b.vy;
    if(b.x-b.r<0){ b.x=b.r; b.vx*=-1;} if(b.x+b.r>canvas.width){ b.x=canvas.width-b.r; b.vx*=-1;}
    if(b.y-b.r<0){ b.y=b.r; b.vy*=-1;}
    if(b.y - b.r > canvas.height){ state.lives--; updateHud(); if(state.lives<=0){ state.level=1; state.score=0; state.lives=3; } resetBall(true); state.running=false; }
    if(b.y+b.r>=p.y-p.h/2 && b.y-b.r<=p.y+p.h/2 && b.x>=p.x-p.w/2 && b.x<=p.x+p.w/2 && b.vy>0){
      const hitPos=(b.x-p.x)/(p.w/2); const angle=hitPos*(Math.PI/3); const speed=Math.hypot(b.vx,b.vy)*1.02;
      b.vx=Math.sin(angle)*speed; b.vy=-Math.cos(angle)*speed; b.y=p.y - p.h/2 - b.r - 1;
    }
    for(const br of state.bricks){
      if(br.hp<=0) continue;
      if(circleRectOverlap(b.x,b.y,b.r,br.x,br.y,br.w,br.h)){
        const dxL=Math.abs((br.x) - (b.x + b.r));
        const dxR=Math.abs((b.x - b.r) - (br.x + br.w));
        const dyT=Math.abs((br.y) - (b.y + b.r));
        const dyB=Math.abs((b.y - b.r) - (br.y + br.h));
        const minPen=Math.min(dxL,dxR,dyT,dyB);
        if(minPen===dxL||minPen===dxR) b.vx*=-1; else b.vy*=-1;
        br.hp -= 1; state.score += (br.type==='black'?20:10); updateHud();
      }
    }
    drawBricks(); drawPaddle(); drawBall(); drawUI();
  }
  function circleRectOverlap(cx,cy,r,rx,ry,rw,rh){
    const nx=Math.max(rx,Math.min(cx,rx+rw)), ny=Math.max(ry,Math.min(cy,ry+rh));
    const dx=cx-nx, dy=cy-ny; return dx*dx+dy*dy<=r*r;
  }

  // controls
  function movePaddle(dirOrX){
    const p=state.paddle;
    if(typeof dirOrX==='number' && Math.abs(dirOrX)<=1){ p.x += dirOrX * p.speed * 2.2; }
    else if(typeof dirOrX==='number'){ p.x = dirOrX; }
    p.x=Math.max(p.w/2,Math.min(canvas.width-p.w/2,p.x));
  }
  addEventListener('keydown',(e)=>{ if(e.key==='ArrowLeft') movePaddle(-1); if(e.key==='ArrowRight') movePaddle(1); if(e.key===' ') launch(); });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); const scaleX=canvas.width/rect.width; movePaddle((e.clientX-rect.left)*scaleX); });
  canvas.addEventListener('touchmove',(e)=>{ const t=e.touches[0]; if(!t) return; const rect=canvas.getBoundingClientRect(); const scaleX=canvas.width/rect.width; movePaddle((t.clientX-rect.left)*scaleX); e.preventDefault(); }, {passive:false});
  canvas.addEventListener('click', ()=>launch()); canvas.addEventListener('touchstart', ()=>launch(), {passive:true});
  function launch(){ if(state.running) return; state.running=true; resetBall(false); }
  btnStart.addEventListener('click', ()=> newGame());

  // fallback matrix (visual only)
  function makeFallbackMatrix(N=21){
    const M=Array.from({length:N},()=>Array(N).fill(0));
    function finder(r0,c0){ for(let r=0;r<7;r++)for(let c=0;c<7;c++){ const edge=r===0||c===0||r===6||c===6||(r>=2&&r<=4&&c>=2&&c<=4); M[r0+r][c0+c]=edge?1:0; } }
    finder(0,0); finder(0,N-7); finder(N-7,0);
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){ const inF=(r<7&&c<7)||(r<7&&c>=N-7)||(r>=N-7&&c<7); if(inF) continue; M[r][c]=Math.random()<0.45?1:0; }
    return M;
  }

  // upload → bricks
  const scaleInput = document.getElementById('scale');
  const qrPrev = document.getElementById('qrPreview');
  

  document.getElementById('btnBuild').addEventListener('click', async ()=>{
    state.modules = Math.max(17, Math.min(177, parseInt(inpModules.value||'21',10)));
    const qMods = Math.max(0, Math.min(16, parseInt(inpQuietModules.value||'4',10)));
    const thresh = Math.max(0, Math.min(255, parseInt(inpThresh.value||'128',10)));

    let img=null;
    const file=document.getElementById('fileQR').files?.[0];
    if(file){
      if(state.lastQRObjectURL){ URL.revokeObjectURL(state.lastQRObjectURL); state.lastQRObjectURL=null; }
      const url=URL.createObjectURL(file); state.lastQRObjectURL=url; qrPrev.src=url; img=await loadImage(url);
    }
    if(!img){
      qrPrev.removeAttribute('src');
      const mat=makeFallbackMatrix(state.modules); currentMatrix=mat; buildBricksFromMatrix(mat, qMods); resetBall(true); state.running=false; updateHud(); return;
    }
    const quietPxGuess=0;
    const mat=await imageToMatrix(img, state.modules, quietPxGuess, thresh);
    currentMatrix=mat; buildBricksFromMatrix(mat, qMods); resetBall(true); state.running=false; updateHud();
  });

  function loadImage(url){ return new Promise((resolve)=>{ const img=new Image(); img.onload=()=>resolve(img); img.src=url; img.crossOrigin='anonymous'; }); }

  // init
  newGame(); requestAnimationFrame(step);

  // back button
  document.getElementById('backBtn').addEventListener('click', function(e){
    e.preventDefault();
    try{
      if(document.referrer && new URL(document.referrer).origin === location.origin){ history.back(); }
      else { location.href = 'qr.html'; } // เปลี่ยนปลายทางได้
    }catch(err){ history.back(); }
  });
  </script>
</body>
</html>
