<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Q-ARE-Code breaker? • UUID12 QR (Mobile)</title>
  <style>
    :root{
      --bg:#e5e7eb;   /* พื้นหลังนอก */
      --fg:#0b0f14;
      --card:#f9fafb; /* พื้นหลังกรอบ gameplay (อ่อนกว่า bg, เข้มกว่า white ของ QR) */
      --bd:rgba(0,0,0,.08);
      --blue:#2563eb;
      color-scheme: light;
    }
    html, body{
      height:100%; margin:0;
      background:var(--bg) !important;
      color:var(--fg) !important;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }
    #wrap{ min-height:100vh; display:flex; flex-direction:column; align-items:center; gap:12px; padding:12px 8px calc(90px + env(safe-area-inset-bottom)); }
    canvas{ background:var(--card); border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.08), inset 0 0 0 1px rgba(0,0,0,.04); touch-action:none; }

    #hud{ display:flex; gap:10px; align-items:center; justify-content:center; font-weight:600; flex-wrap:wrap; }
    .pill{ padding:6px 10px; border-radius:999px; background:#f3f4f6; border:1px solid var(--bd); }

    #btnStart{ cursor:pointer; border:none; color:white; padding:8px 14px; border-radius:10px; font-weight:700; background:var(--blue); }

    /* controls: เหลือเฉพาะ UUID */
    #controls{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; align-items:center; }

    .back-fixed{
      position:fixed; left:12px; bottom:calc(16px + env(safe-area-inset-bottom)); z-index:1000;
      display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px;
      border:1px solid var(--bd); background:rgba(0,0,0,.04); color:var(--fg); font-weight:700; cursor:pointer;
    }
    .back-fixed svg{ opacity:.9 }
  </style>
</head>
<body>
  <button id="backBtn" class="back-fixed" type="button" aria-label="ย้อนกลับ">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    ย้อนกลับ
  </button>

  <div id="wrap">
    <!-- Mobile-first 360x640 -->
    <canvas id="game" width="360" height="640" aria-label="Q-ARE-Code breaker?"></canvas>

    <div id="hud">
      <div class="pill">คะแนน: <span id="score">0</span></div>
      <div class="pill">ด่าน: <span id="level">1</span></div>
      <div class="pill">ชีวิต: <span id="lives">3</span></div>
      <button id="btnStart">เริ่ม / รีเซ็ต</button>
    </div>

    <!-- เหลือเฉพาะ UUID ด้านล่าง -->
    <div id="controls">
      <div class="pill"><b>UUID12:</b> <code id="uuidText" style="font-weight:700"></code></div>
    </div>
  </div>

  <script>
  // ----- setup -----
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');

  const scoreEl=document.getElementById('score');
  const levelEl=document.getElementById('level');
  const livesEl=document.getElementById('lives');
  const btnStart=document.getElementById('btnStart');
  const uuidText=document.getElementById('uuidText');

  const state={
    running:false, level:1, score:0, lives:3,
    // ถาดรองตามที่ขอ: w = 50
    paddle:{x:canvas.width/2, y:canvas.height-28, w:70, h:12, speed:9},
    // ลูกบอลเล็กลง r=6
    ball:{x:canvas.width/2, y:canvas.height-80, r:6, vx:0, vy:0, speed:5},
    bricks:[], gridMeta:null,
    qrImg:null, currentMatrix:null,
    gridScale:0.8,
    effects:[]
  };

  // ---- responsive ----
  function fitCanvas(){
    const baseW=360, baseH=640;
    const maxW=Math.min(window.innerWidth-24, 420);
    const scale=Math.min(maxW/baseW, 1);
    canvas.style.width=Math.round(baseW*scale)+'px';
    canvas.style.height=Math.round(baseH*scale)+'px';
  }
  addEventListener('resize',fitCanvas); fitCanvas();

  // ---- drawing ----
  function drawPaddle(){ const p=state.paddle; ctx.fillStyle='#1f2937'; ctx.fillRect(Math.round(p.x-p.w/2),Math.round(p.y-p.h/2),p.w,p.h); }
  function drawBall(){ const b=state.ball; ctx.fillStyle='#ef4444'; ctx.beginPath(); ctx.arc(Math.round(b.x),Math.round(b.y),b.r,0,Math.PI*2); ctx.fill(); }
  function drawBricks(){
    // วาดเฉพาะบล็อก "ดำ" ที่ยังไม่แตก (ช่องขาว = ว่าง/ทะลุ)
    for(const br of state.bricks){
      if(br.cleared || br.hp<=0) continue;
      ctx.fillStyle = '#000000';
      ctx.fillRect(br.x,br.y,br.w,br.h);
    }
  }
  function drawEffects(){
    // วงแหวน + สปาร์ค (ชัดขึ้น)
    for(let i=state.effects.length-1; i>=0; i--){
      const e=state.effects[i];
      if(e.kind==='ring'){
        ctx.save();
        ctx.globalAlpha = e.alpha;
        ctx.lineWidth = e.lineWidth;
        ctx.strokeStyle = e.color;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
        // วงรอง
        ctx.save();
        ctx.globalAlpha = e.alpha*0.6;
        ctx.lineWidth = Math.max(1, e.lineWidth-1);
        ctx.strokeStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r*0.65, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();

        e.r += e.growth;
        e.alpha *= e.decay;
        if(e.alpha < 0.04) state.effects.splice(i,1);
      } else if(e.kind==='spark'){
        ctx.save();
        ctx.globalAlpha = e.alpha;
        ctx.lineWidth = 2;
        ctx.strokeStyle = e.color;
        ctx.beginPath();
        ctx.moveTo(e.x, e.y);
        ctx.lineTo(e.x - Math.cos(e.angle)*e.len, e.y - Math.sin(e.angle)*e.len);
        ctx.stroke();
        ctx.restore();

        e.x += Math.cos(e.angle)*e.speed;
        e.y += Math.sin(e.angle)*e.speed;
        e.len *= 0.95;
        e.alpha *= 0.9;
        if(e.alpha < 0.05 || e.len < 2) state.effects.splice(i,1);
      }
    }
  }
  function drawUI(){
    const b=state.ball;
    if(!state.running && b.vx===0 && b.vy===0){
      ctx.fillStyle='rgba(0,0,0,0.35)';
      ctx.textAlign='center';
      ctx.font='bold 20px ui-sans-serif, system-ui';
      ctx.fillText('กด Space / แตะ เพื่อเริ่ม', canvas.width/2, canvas.height - 18);
    }
  }
  function drawFrame(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBricks();
    drawEffects();
    drawPaddle();
    drawBall();
    drawUI();
  }

  // ---- gameplay core ----
  function resetBall(onPaddle=true){
    const p=state.paddle, b=state.ball;
    b.x=p.x; b.y=p.y - p.h/2 - b.r - 2; b.vx=0; b.vy=0;
    if(!onPaddle){
      const angle=(-60+Math.random()*120)*Math.PI/180;
      b.vx=Math.cos(angle)*b.speed;
      b.vy=Math.sin(angle)*b.speed;
    }
  }
  function updateHud(){ scoreEl.textContent=state.score; levelEl.textContent=state.level; livesEl.textContent=state.lives; }
  function newGame(){ state.level=1; state.score=0; state.lives=3; updateHud(); resetBall(true); state.running=false; drawFrame(); }

  function step(){
    requestAnimationFrame(step);
    const p=state.paddle, b=state.ball;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(b.vx===0 && b.vy===0){ b.x=p.x; b.y=p.y - p.h/2 - b.r - 2; }
    b.x+=b.vx; b.y+=b.vy;

    if(b.x-b.r<0){ b.x=b.r; b.vx*=-1; }
    if(b.x+b.r>canvas.width){ b.x=canvas.width-b.r; b.vx*=-1; }
    if(b.y-b.r<0){ b.y=b.r; b.vy*=-1; }
    if(b.y-b.r>canvas.height){
      state.lives--; updateHud();
      if(state.lives<=0){ state.level=1; state.score=0; state.lives=3; }
      resetBall(true); state.running=false;
    }

    // ชนแพดเดิล
    if(b.y+b.r>=p.y-p.h/2 && b.y-b.r<=p.y+p.h/2 && b.x>=p.x-p.w/2 && b.x<=p.x+p.w/2 && b.vy>0){
      const hitPos=(b.x-p.x)/(p.w/2);
      const angle=hitPos*(Math.PI/3);
      const speed=Math.hypot(b.vx,b.vy)*1.015; // คงความรู้สึกดีดเล็กน้อยไว้เฉพาะแพดเดิล
      b.vx=Math.sin(angle)*speed;
      b.vy=-Math.cos(angle)*speed;
      b.y=p.y - p.h/2 - b.r - 1;
    }

    // ชนอิฐดำ (ไม่มีการบูสต์ความเร็ว)
    for(const br of state.bricks){
      if(br.hp<=0 || br.cleared) continue;
      if(circleRectOverlap(b.x,b.y,b.r,br.x,br.y,br.w,br.h)){
        // แกนสะท้อน
        const dxL=Math.abs((br.x) - (b.x + b.r));
        const dxR=Math.abs((b.x - b.r) - (br.x + br.w));
        const dyT=Math.abs((br.y) - (b.y + b.r));
        const dyB=Math.abs((b.y - b.r) - (br.y + br.h));
        const minPen=Math.min(dxL,dxR,dyT,dyB);
        if(minPen===dxL||minPen===dxR) b.vx*=-1; else b.vy*=-1;

        // จุดกระทบ + เอฟเฟกต์ชัดขึ้น
        const hitX = Math.max(br.x, Math.min(b.x, br.x+br.w));
        const hitY = Math.max(br.y, Math.min(b.y, br.y+br.h));
        addReflectFlashStrong(hitX, hitY, Math.min(br.w, br.h));

        // แตกทีเดียว
        br.hp = 0; br.cleared = true;
        state.score += 10; updateHud();
        break;
      }
    }

    drawBricks();
    drawEffects();
    drawPaddle();
    drawBall();
    drawUI();
  }

  function circleRectOverlap(cx,cy,r,rx,ry,rw,rh){
    const nx=Math.max(rx,Math.min(cx,rx+rw)), ny=Math.max(ry,Math.min(cy,ry+rh));
    const dx=cx-nx, dy=cy-ny; return dx*dx+dy*dy<=r*r;
  }

  // ---- reflect effect helpers (ชัดขึ้น) ----
  function addReflectFlashStrong(cx, cy, baseR){
    const ringColor = '#7dd3fc'; // ฟ้าใส
    // วงแหวนหลัก
    state.effects.push({
      kind:'ring',
      x: cx, y: cy,
      r: Math.max(3, baseR*0.4),
      growth: Math.max(2.2, baseR*0.25),
      alpha: 0.9,
      decay: 0.88,
      lineWidth: 3,
      color: ringColor
    });
    // วงแหวนรอง
    state.effects.push({
      kind:'ring',
      x: cx, y: cy,
      r: Math.max(2, baseR*0.22),
      growth: Math.max(1.7, baseR*0.20),
      alpha: 0.75,
      decay: 0.88,
      lineWidth: 2,
      color: '#93c5fd'
    });
    // สปาร์ค
    const sparks = 8;
    for(let i=0;i<sparks;i++){
      const angle = Math.random()*Math.PI*2;
      state.effects.push({
        kind:'spark',
        x: cx, y: cy,
        angle,
        len: Math.max(8, baseR*0.8)*(0.7+Math.random()*0.6),
        speed: 1.8 + Math.random()*1.2,
        alpha: 0.9,
        color: '#ffffff'
      });
    }
  }

  // ---- controls ----
  function movePaddle(dirOrX){
    const p=state.paddle;
    if(typeof dirOrX==='number' && Math.abs(dirOrX)<=1){ p.x+=dirOrX*p.speed*2.2; }
    else if(typeof dirOrX==='number'){ p.x=dirOrX; }
    p.x=Math.max(p.w/2, Math.min(canvas.width-p.w/2, p.x));
  }
  function launch(){ if(state.running) return; state.running=true; resetBall(false); }
  addEventListener('keydown',e=>{ if(e.key==='ArrowLeft')movePaddle(-1); if(e.key==='ArrowRight')movePaddle(1); if(e.key===' ')launch(); });
  canvas.addEventListener('mousemove',e=>{ const rect=canvas.getBoundingClientRect(); const scaleX=canvas.width/rect.width; movePaddle((e.clientX-rect.left)*scaleX); });
  canvas.addEventListener('touchmove',e=>{ const t=e.touches[0]; if(!t) return; const rect=canvas.getBoundingClientRect(); const scaleX=canvas.width/rect.width; movePaddle((t.clientX-rect.left)*scaleX); e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchstart', ()=>launch(), {passive:true});
  canvas.addEventListener('click', ()=>launch());

  // ---- QR helpers ----
  function uuid12(){
    const bytes=(crypto&&crypto.getRandomValues)?crypto.getRandomValues(new Uint8Array(6)):new Uint8Array(6).map(()=>Math.floor(Math.random()*256));
    return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');
  }
  function loadImage(url){ return new Promise(resolve=>{ const img=new Image(); img.onload=()=>resolve(img); img.src=url; img.crossOrigin='anonymous'; }); }
  async function makeQRFromUUID(){
    const id=uuid12();
    uuidText.textContent=id;
    const url=`https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(id)}&ecc=M&margin=0`;
    const img=await loadImage(url); state.qrImg=img;
    const thresh=128; // ค่าคงที่ (ไม่มีอินพุตแล้ว)
    state.currentMatrix=await imageToMatrix(img, null, 0, thresh);
    buildBricksFromMatrix(state.currentMatrix); // สร้างเฉพาะดำ
    resetBall(true); state.running=false; updateHud(); drawFrame();
  }

  async function imageToMatrix(img, modules, quietPx, thresh){
    const off=document.createElement('canvas'); const N=Math.max(img.width,img.height);
    off.width=off.height=N; const octx=off.getContext('2d');
    const sc=Math.min(N/img.width, N/img.height); const w=img.width*sc, h=img.height*sc;
    octx.fillStyle='#fff'; octx.fillRect(0,0,N,N);
    octx.drawImage(img,(N-w)/2,(N-h)/2,w,h);
    if(!modules){ modules=21; } // ใช้ 21 ให้ stable
    const start=quietPx, end=N-quietPx, size=end-start, cell=size/modules, matrix=[];
    for(let r=0;r<modules;r++){
      const row=[];
      for(let c=0;c<modules;c++){
        const sx=Math.floor(start+c*cell), sy=Math.floor(start+r*cell);
        const sw=Math.max(1,Math.ceil(cell)), sh=Math.max(1,Math.ceil(cell));
        const data=octx.getImageData(sx,sy,sw,sh).data;
        let sum=0,cnt=0;
        for(let i=0;i<data.length;i+=4){
          sum+=0.2126*data[i]+0.7152*data[i+1]+0.0722*data[i+2];
          cnt++;
        }
        row.push((sum/cnt)<thresh?1:0); // 1 = ดำ, 0 = ขาว
      }
      row.length && matrix.push(row);
    }
    return matrix;
  }

  // ✅ เฉพาะ "ดำ" เท่านั้น (ไม่มี quiet zone)
  function buildBricksFromMatrix(mat){
    const rows=mat.length, cols=mat[0].length;
    const maxW=Math.min(canvas.width-16, Math.round(canvas.width*state.gridScale));
    const maxH=Math.floor(Math.min(canvas.height*0.45, canvas.height*state.gridScale));
    const totalCols=cols, totalRows=rows;
    let moduleSize=Math.floor(Math.min(maxW/totalCols, maxH/totalRows));
    moduleSize=Math.max(6, moduleSize);

    const gridW=totalCols*moduleSize, gridH=totalRows*moduleSize;
    const startX=Math.floor((canvas.width - gridW)/2);
    const startY=32;

    const bricks=[]; let id=1;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(mat[r][c]!==1) continue; // เฉพาะดำ
        const x=startX + c*moduleSize;
        const y=startY + r*moduleSize;
        bricks.push({ id:id++, x,y, w:moduleSize, h:moduleSize, hp:1, type:'black', cleared:false });
      }
    }
    state.bricks=bricks;
    state.gridMeta={ startX,startY,moduleSize,cols,rows };
  }

  // ---- init ----
  function movePaddle(dirOrX){
    const p=state.paddle;
    if(typeof dirOrX==='number' && Math.abs(dirOrX)<=1){ p.x+=dirOrX*p.speed*2.2; }
    else if(typeof dirOrX==='number'){ p.x=dirOrX; }
    p.x=Math.max(p.w/2, Math.min(canvas.width-p.w/2, p.x));
  }
  function launch(){ if(state.running) return; state.running=true; resetBall(false); }

  addEventListener('keydown',e=>{ if(e.key==='ArrowLeft')movePaddle(-1); if(e.key==='ArrowRight')movePaddle(1); if(e.key===' ')launch(); });
  canvas.addEventListener('mousemove',e=>{ const rect=canvas.getBoundingClientRect(); const scaleX=canvas.width/rect.width; movePaddle((e.clientX-rect.left)*scaleX); });
  canvas.addEventListener('touchmove',e=>{ const t=e.touches[0]; if(!t) return; const rect=canvas.getBoundingClientRect(); const scaleX=canvas.width/rect.width; movePaddle((t.clientX-rect.left)*scaleX); e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchstart', ()=>launch(), {passive:true});
  canvas.addEventListener('click', ()=>launch());

  newGame();
  requestAnimationFrame(step);
  makeQRFromUUID();

  // back button
  document.getElementById('backBtn').addEventListener('click', function(e){
    e.preventDefault();
    try{
      if(document.referrer && new URL(document.referrer).origin === location.origin){ history.back(); }
      else { location.href = 'index.html'; }
    }catch(err){ history.back(); }
  });
  </script>
</body>
</html>
