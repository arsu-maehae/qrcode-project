<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QR Brick Breaker – Tight QR Blocks (Scannable)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e6edf3; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #wrap { display: grid; place-items: center; height: 100%; gap: 8px; }
    canvas { background: #0f1720; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.05); touch-action: none; }
    #hud { display:flex; gap:14px; align-items:center; justify-content:center; font-weight:600; }
    .pill { padding: 6px 10px; border-radius: 999px; background: #111a24; border: 1px solid rgba(255,255,255,.08); }
    #btnStart { cursor:pointer; background:#1e88ff; border:none; color:white; padding:8px 14px; border-radius:10px; font-weight:700; }
    #help { max-width: 980px; opacity:.85; line-height:1.4; font-size: 14px; text-align:center; }
    #controls { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; align-items:center; }
    #qrPreviewWrap { display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
    #qrPreview { image-rendering: pixelated; background:#fff; padding:10px; border-radius:12px; box-shadow: 0 6px 20px rgba(0,0,0,.35); }
    a { color:#6ab7ff; }
    input[type="number"], input[type="range"] { background:#0b1220; color:#e6edf3; border:1px solid rgba(255,255,255,.15); border-radius:8px; padding:4px 6px; }
    label { opacity:.85; font-size:13px; }

    /* Back button (fixed bottom-left) */
    .back {
      position: fixed; left: 12px; bottom: calc(16px + env(safe-area-inset-bottom));
      z-index: 1000; display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 12px; border-radius: 12px; cursor: pointer; font-weight: 700;
      background: rgba(255,255,255,.06); color: #e6edf3;
      border: 1px solid rgba(255,255,255,.12); box-shadow: 0 6px 20px rgba(0,0,0,.35);
    }
    .back svg { opacity: .9 }
    .back:active { transform: translateY(1px); }
  </style>
</head>
<body>

  <!-- ปุ่มย้อนกลับ มุมซ้ายล่าง -->
  <button id="backBtn" class="back" type="button" aria-label="ย้อนกลับ">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
    ย้อนกลับ
  </button>

  <div id="wrap">
    <canvas id="game" width="900" height="600" aria-label="QR Brick Breaker"></canvas>
    <div id="hud">
      <div class="pill">คะแนน: <span id="score">0</span></div>
      <div class="pill">ด่าน: <span id="level">1</span></div>
      <div class="pill">ชีวิต: <span id="lives">3</span></div>
      <button id="btnStart">เริ่ม / รีเซ็ต</button>
    </div>

    <div id="controls">
      <div class="pill">อัปโหลดภาพ QR: <input type="file" id="fileQR" accept="image/*" /></div>
      <div class="pill">
        <label>โมดูล/ด้าน</label>
        <input id="modules" type="number" value="21" min="17" max="177" step="1" style="width:72px;" />
      </div>
      <div class="pill">
        <label>Quiet zone (modules)</label>
        <input id="quietModules" type="number" value="4" min="0" max="16" step="1" style="width:64px;" />
      </div>
      <div class="pill">
        <label>Threshold</label>
        <input id="thresh" type="number" value="128" min="0" max="255" step="1" style="width:64px;" />
      </div>
      <div class="pill" title="ย่อ/ขยายขนาดกริด (จำกัดความสูง ~50% จอ)">
        <label>ขนาดกริด (%)</label>
        <input id="scale" type="range" min="30" max="100" value="70" />
        <span id="scaleVal">70%</span>
      </div>
      <button id="btnBuild" style="cursor:pointer;background:#14b8a6;border:none;color:white;padding:8px 14px;border-radius:10px;font-weight:700;">ใช้ภาพ QR สร้างอิฐ</button>
    </div>

    <div id="qrPreviewWrap">
      <div class="pill" style="background:transparent;border:none;box-shadow:none">
        <b>สแกน QR ได้ตั้งแต่ตอนนี้เลย →</b>
      </div>
      <img id="qrPreview" alt="ตัวอย่าง QR (สแกนได้)" draggable="false" width="180" height="180" />
    </div>

    <div id="help">
      เวอร์ชันนี้ทำให้โมดูล QR เป็น <b>บล็อกสี่เหลี่ยมติดกันสนิท</b> (ไม่มีช่องว่าง) เพื่อให้ <b>สแกนได้จริง</b> ขณะยังไม่เริ่มเกมด้วยค่ะ
    </div>
  </div>

  <script>
  // =====================
  // QR Brick Breaker – Tight Scannable QR Blocks
  // =====================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const livesEl = document.getElementById('lives');
  const btnStart = document.getElementById('btnStart');
  const btnBuild = document.getElementById('btnBuild');
  const inpModules = document.getElementById('modules');
  const inpQuietModules = document.getElementById('quietModules');
  const inpThresh = document.getElementById('thresh');
  const inpScale = document.getElementById('scale');
  const scaleVal = document.getElementById('scaleVal');
  const fileQR = document.getElementById('fileQR');
  const qrPreview = document.getElementById('qrPreview');

  // Back button handler
  const backBtn = document.getElementById('backBtn');
  if (backBtn) {
    backBtn.addEventListener('click', (e) => {
      e.preventDefault();
      try {
        if (document.referrer && new URL(document.referrer).origin === location.origin) {
          history.back();
        } else {
          // เปลี่ยนปลายทางได้ตามต้องการ
          window.location.href = 'qr.html';
        }
      } catch (err) {
        history.back();
      }
    });
  }

  function fitCanvas() {
    const maxW = Math.min(window.innerWidth - 24, 1000);
    const maxH = Math.min(window.innerHeight - 260, 700);
    const baseW = 900, baseH = 600;
    const scale = Math.min(maxW/baseW, maxH/baseH, 1);
    canvas.style.width = (baseW*scale|0) + 'px';
    canvas.style.height = (baseH*scale|0) + 'px';
  }
  addEventListener('resize', fitCanvas); fitCanvas();

  const state = {
    running: false,
    level: 1,
    score: 0,
    lives: 3,
    paddle: { x: canvas.width/2, y: canvas.height-28, w: 120, h: 12, speed: 10 },
    ball:   { x: canvas.width/2, y: canvas.height-80, r: 8, vx: 0, vy: 0, speed: 7 },
    bricks: [],
    modules: 21,
    gridScale: 0.7,
    lastQRObjectURL: null,
    gridMeta: null, // {startX,startY,moduleSize,cols,rows,quietModules}
  };

  inpScale.addEventListener('input', ()=>{
    scaleVal.textContent = inpScale.value + '%';
    state.gridScale = parseInt(inpScale.value,10)/100;
    rebuildFromCurrentMatrix();
  });

  // --- Matrix & build ---
  function brightness(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
  async function imageToMatrix(img, modules, quietPx, thresh){
    const off = document.createElement('canvas');
    const N = Math.max(img.width, img.height);
    off.width = off.height = N;
    const octx = off.getContext('2d');
    const scale = Math.min(N/img.width, N/img.height);
    const w = img.width*scale, h = img.height*scale;
    octx.fillStyle = '#fff'; octx.fillRect(0,0,N,N);
    octx.drawImage(img, (N-w)/2, (N-h)/2, w, h);
    const start = quietPx, end = N - quietPx; const area = {x:start, y:start, size:end-start};
    const cell = area.size / modules; const matrix = [];
    for(let r=0;r<modules;r++){
      const row=[];
      for(let c=0;c<modules;c++){
        const sx = Math.floor(area.x + c*cell);
        const sy = Math.floor(area.y + r*cell);
        const sw = Math.max(1, Math.ceil(cell)), sh = Math.max(1, Math.ceil(cell));
        const data = octx.getImageData(sx, sy, sw, sh).data;
        let sum=0, count=0; for(let i=0;i<data.length;i+=4){ sum += brightness(data[i],data[i+1],data[i+2]); count++; }
        const avg = sum / count; row.push(avg < thresh ? 1 : 0);
      }
      matrix.push(row);
    }
    return matrix;
  }

  function buildBricksFromMatrix(mat, quietModules=4){
    const rows = mat.length, cols = mat[0].length;

    // Compute module size (include quiet zone)
    const maxW = canvas.width - 16;
    const maxH = Math.floor(canvas.height * 0.5);
    const totalCols = cols + quietModules*2;
    const totalRows = rows + quietModules*2;

    let moduleSize = Math.floor(Math.min(maxW / totalCols, maxH / totalRows));
    moduleSize = Math.max(6, moduleSize);

    const gridW = totalCols * moduleSize;
    const gridH = totalRows * moduleSize;
    const startX = Math.floor((canvas.width - gridW)/2);
    const startY = 48;

    // build
    const bricks=[]; let id=1;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = startX + (c + quietModules) * moduleSize;
        const y = startY + (r + quietModules) * moduleSize;
        const black = mat[r][c]===1;
        bricks.push({ id:id++, x, y, w:moduleSize, h:moduleSize, hp:black?2:1, type:black?'black':'white' });
      }
    }
    state.bricks = bricks;
    state.gridMeta = { startX, startY, moduleSize, cols, rows, quietModules };
  }

  // Keep a copy of the current matrix to rebuild on scale change
  let currentMatrix = null;
  function rebuildFromCurrentMatrix(){
    if(!currentMatrix) return;
    buildBricksFromMatrix(currentMatrix, state.gridMeta?state.gridMeta.quietModules:4);
    resetBall(true); state.running=false;
  }

  // --- Draw ---
  function drawQuietZone(){
    if(!state.gridMeta) return;
    const {startX,startY,moduleSize,cols,rows,quietModules} = state.gridMeta;
    const totalW = (cols + quietModules*2) * moduleSize;
    const totalH = (rows + quietModules*2) * moduleSize;
    ctx.fillStyle = '#fff';
    ctx.fillRect(startX, startY, totalW, totalH);
  }
  function drawPaddle(){ const p=state.paddle; ctx.fillStyle='#b3e1ff'; ctx.fillRect(Math.round(p.x-p.w/2), Math.round(p.y-p.h/2), p.w, p.h); }
  function drawBall(){ const b=state.ball; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(Math.round(b.x), Math.round(b.y), b.r, 0, Math.PI*2); ctx.fill(); }
  function drawBricks(){
    drawQuietZone();
    for(const br of state.bricks){ if(br.hp<=0) continue; ctx.fillStyle = br.type==='black'? (br.hp===1?'#222':'#000') : '#fff'; ctx.fillRect(br.x, br.y, br.w, br.h); }
  }
  function drawUI(){
    if(!state.running && state.ball.vx===0 && state.ball.vy===0){
      ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.textAlign='center'; ctx.font='bold 24px ui-sans-serif, system-ui';
      ctx.fillText('กด Space / แตะ เพื่อเริ่ม', canvas.width/2, canvas.height - 18);
    }
  }

  // --- Physics ---
  function resetBall(onPaddle=true){
    const p=state.paddle,b=state.ball;
    b.x=p.x; b.y=p.y - p.h/2 - b.r - 2; b.vx=0; b.vy=0;
    if(!onPaddle){
      const angle = (-60 + Math.random()*120)*Math.PI/180;
      b.vx=Math.cos(angle)*b.speed; b.vy=Math.sin(angle)*b.speed;
    }
  }
  function updateHud(){ scoreEl.textContent = state.score; levelEl.textContent = state.level; livesEl.textContent = state.lives; }
  function newGame(){
    state.level=1; state.score=0; state.lives=3;
    const mat = makeFallbackMatrix(state.modules);
    currentMatrix = mat; buildBricksFromMatrix(mat, 4);
    resetBall(true); state.running=false; updateHud();
  }

  function step(){
    requestAnimationFrame(step);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const p=state.paddle,b=state.ball;
    if(b.vx===0&&b.vy===0){ b.x=p.x; b.y=p.y - p.h/2 - b.r - 2; }
    b.x+=b.vx; b.y+=b.vy;
    if(b.x-b.r<0){ b.x=b.r; b.vx*=-1;}
    if(b.x+b.r>canvas.width){ b.x=canvas.width-b.r; b.vx*=-1;}
    if(b.y-b.r<0){ b.y=b.r; b.vy*=-1; }
    if(b.y - b.r > canvas.height){
      state.lives--; updateHud();
      if(state.lives<=0){ state.level=1; state.score=0; state.lives=3; }
      resetBall(true); state.running=false;
    }
    if(b.y+b.r>=p.y-p.h/2 && b.y-b.r<=p.y+p.h/2 && b.x>=p.x-p.w/2 && b.x<=p.x+p.w/2 && b.vy>0){
      const hitPos=(b.x-p.x)/(p.w/2); const angle=hitPos*(Math.PI/3);
      const speed=Math.hypot(b.vx,b.vy)*1.02;
      b.vx=Math.sin(angle)*speed; b.vy=-Math.cos(angle)*speed; b.y=p.y - p.h/2 - b.r - 1;
    }
    for(const br of state.bricks){
      if(br.hp<=0) continue;
      if(circleRectOverlap(b.x,b.y,b.r,br.x,br.y,br.w,br.h)){
        const dxL=Math.abs((br.x) - (b.x + b.r));
        const dxR=Math.abs((b.x - b.r) - (br.x + br.w));
        const dyT=Math.abs((br.y) - (b.y + b.r));
        const dyB=Math.abs((b.y - b.r) - (br.y + br.h));
        const minPen=Math.min(dxL,dxR,dyT,dyB);
        if(minPen===dxL||minPen===dxR) b.vx*=-1; else b.vy*=-1;
        br.hp -= 1; state.score += (br.type==='black'?20:10); updateHud();
      }
    }
    drawBricks(); drawPaddle(); drawBall(); drawUI();
  }

  function circleRectOverlap(cx,cy,r,rx,ry,rw,rh){
    const nx=Math.max(rx,Math.min(cx,rx+rw)); const ny=Math.max(ry,Math.min(cy,ry+rh));
    const dx=cx-nx, dy=cy-ny; return dx*dx+dy*dy<=r*r;
  }

  // Controls
  function movePaddle(dirOrX){
    const p=state.paddle;
    if(typeof dirOrX==='number' && Math.abs(dirOrX)<=1){ p.x += dirOrX * p.speed * 2.2; }
    else if(typeof dirOrX==='number'){ p.x = dirOrX; }
    p.x=Math.max(p.w/2,Math.min(canvas.width-p.w/2,p.x));
  }
  addEventListener('keydown', (e)=>{ if(e.key==='ArrowLeft') movePaddle(-1); if(e.key==='ArrowRight') movePaddle(1); if(e.key===' ') launch(); });
  canvas.addEventListener('mousemove',(e)=>{ const rect=canvas.getBoundingClientRect(); const scaleX=canvas.width/rect.width; movePaddle((e.clientX-rect.left)*scaleX); });
  canvas.addEventListener('touchmove',(e)=>{ const t=e.touches[0]; if(!t) return; const rect=canvas.getBoundingClientRect(); const scaleX=canvas.width/rect.width; movePaddle((t.clientX-rect.left)*scaleX); e.preventDefault(); }, {passive:false});
  canvas.addEventListener('click', ()=>launch()); canvas.addEventListener('touchstart', ()=>launch(), {passive:true});

  function launch(){ if(state.running) return; state.running=true; resetBall(false); }
  btnStart.addEventListener('click', ()=>{ newGame(); });

  // Fallback QR-like matrix (startup only)
  function makeFallbackMatrix(N=21){
    const M = Array.from({length:N},()=>Array(N).fill(0));
    function finder(r0,c0){ for(let r=0;r<7;r++)for(let c=0;c<7;c++){ const edge = r===0||c===0||r===6||c===6|| (r>=2&&r<=4&&c>=2&&c<=4); M[r0+r][c0+c] = edge?1:0; } }
    finder(0,0); finder(0,N-7); finder(N-7,0);
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      const inFinder = (r<7&&c<7)||(r<7&&c>=N-7)||(r>=N-7&&c<7); if(inFinder) continue;
      M[r][c] = Math.random()<0.45?1:0;
    }
    return M;
  }

  // Build from upload & show preview
  btnBuild.addEventListener('click', async ()=>{
    state.modules = Math.max(17, Math.min(177, parseInt(inpModules.value||'21',10)));
    const qMods = Math.max(0, Math.min(16, parseInt(inpQuietModules.value||'4',10)));
    const thresh = Math.max(0, Math.min(255, parseInt(inpThresh.value||'128',10)));

    let img = null;
    const file = fileQR.files && fileQR.files[0];
    if(file){
      if(state.lastQRObjectURL){ URL.revokeObjectURL(state.lastQRObjectURL); state.lastQRObjectURL=null; }
      const url = URL.createObjectURL(file);
      state.lastQRObjectURL = url; qrPreview.src = url; img = await loadImage(url);
    }

    if(!img){
      qrPreview.removeAttribute('src');
      const mat = makeFallbackMatrix(state.modules);
      currentMatrix = mat; buildBricksFromMatrix(mat, qMods);
      resetBall(true); state.running=false; updateHud(); return;
    }

    const quietPxGuess = 0;
    const mat = await imageToMatrix(img, state.modules, quietPxGuess, thresh);
    currentMatrix = mat; buildBricksFromMatrix(mat, qMods);
    resetBall(true); state.running=false; updateHud();
  });

  function loadImage(url){
    return new Promise((resolve)=>{
      const img=new Image(); img.onload=()=>resolve(img); img.src = url; img.crossOrigin='anonymous';
    });
  }

  // Init
  newGame();
  requestAnimationFrame(step);
  </script>
</body>
</html>
